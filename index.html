<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bold Scanner Pro</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script async src="https://docs.opencv.org/4.7.0/opencv.js" type="text/javascript"></script>
    <style>
        :root { --primary: #007AFF; --bg: #000; --surface: #1C1C1E; --text: #FFF; }
        body { font-family: sans-serif; background: var(--bg); color: var(--text); margin: 0; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        header { padding: 15px; background: #1c1c1e; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #333; }
        #viewport { flex: 1; display: flex; align-items: center; justify-content: center; padding: 10px; position: relative; overflow: hidden; }
        canvas { max-width: 100%; max-height: 100%; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        .controls { background: var(--surface); padding: 20px; display: flex; flex-direction: column; gap: 15px; border-radius: 20px 20px 0 0; }
        .btn-group { display: flex; justify-content: space-around; align-items: center; }
        .filter-row { display: none; gap: 10px; overflow-x: auto; padding-bottom: 10px; }
        .filter-btn { background: #333; border: none; color: white; padding: 8px 15px; border-radius: 10px; white-space: nowrap; font-size: 12px; }
        .active { background: var(--primary) !important; }
        .main-btn { background: var(--primary); color: white; border: none; padding: 15px 30px; border-radius: 30px; font-weight: bold; width: 100%; }
        #loading { position: absolute; text-align: center; width: 100%; }
        input[type="file"] { display: none; }
    </style>
</head>
<body>

<header>
    <div style="font-weight: 800; color: var(--primary)">BOLD SCANNER</div>
    <div id="status" style="font-size: 12px; opacity: 0.6">Engine Offline</div>
</header>

<div id="viewport">
    <div id="loading"><h3>Awaiting Image...</h3><p>Ensure OpenCV is loaded (Green dot)</p></div>
    <canvas id="canvasOutput"></canvas>
</div>

<div class="controls">
    <div class="filter-row" id="filterRow">
        <button class="filter-btn active" onclick="applyEffect('scan')">Auto-Scan</button>
        <button class="filter-btn" onclick="applyEffect('magic')">Magic White</button>
        <button class="filter-btn" onclick="applyEffect('bw')">B&W</button>
        <button class="filter-btn" onclick="applyEffect('orig')">Original</button>
    </div>
    <div class="btn-group">
        <button class="main-btn" onclick="document.getElementById('fileInput').click()">UPLOAD / CAPTURE</button>
        <button id="dlBtn" style="display:none; width: 50px; height: 50px; border-radius: 50%; border: none; background: #333; color: white; margin-left: 10px;" onclick="exportPDF()">PDF</button>
    </div>
</div>

<input type="file" id="fileInput" accept="image/*">

<script>
let srcMat, scanMat;
const canvas = document.getElementById('canvasOutput');

var Module = {
    onRuntimeInitialized() {
        document.getElementById('status').innerHTML = "<span style='color:#30D158'>‚óè</span> Engine Ready";
    }
};

document.getElementById('fileInput').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
        const img = new Image();
        img.onload = () => {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('filterRow').style.display = 'flex';
            document.getElementById('dlBtn').style.display = 'block';
            srcMat = cv.imread(img);
            performPerspectiveWarp(srcMat);
        };
        img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
});

function performPerspectiveWarp(src) {
    let dst = new cv.Mat();
    let gray = new cv.Mat();
    let blurred = new cv.Mat();
    let edged = new cv.Mat();

    // 1. Pre-process
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
    cv.Canny(blurred, edged, 75, 200);

    // 2. Find Contours
    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(edged, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    let maxArea = 0;
    let biggestContour = null;

    for (let i = 0; i < contours.size(); i++) {
        let cnt = contours.get(i);
        let area = cv.contourArea(cnt);
        let peri = cv.arcLength(cnt, true);
        let approx = new cv.Mat();
        cv.approxPolyDP(cnt, approx, 0.02 * peri, true);

        if (area > maxArea && approx.rows === 4) {
            maxArea = area;
            biggestContour = approx;
        }
    }

    if (biggestContour) {
        // 3. Perspective Warp Logic
        let corners = [];
        for (let i = 0; i < 4; i++) {
            corners.push({ x: biggestContour.data32S[i * 2], y: biggestContour.data32S[i * 2 + 1] });
        }

        // Sort corners: top-left, top-right, bottom-right, bottom-left
        corners.sort((a, b) => a.y - b.y);
        let tl = corners[0].x < corners[1].x ? corners[0] : corners[1];
        let tr = corners[0].x < corners[1].x ? corners[1] : corners[0];
        let bl = corners[2].x < corners[3].x ? corners[2] : corners[3];
        let br = corners[2].x < corners[3].x ? corners[3] : corners[2];

        let width = Math.max(Math.hypot(br.x - bl.x, br.y - bl.y), Math.hypot(tr.x - tl.x, tr.y - tl.y));
        let height = Math.max(Math.hypot(tr.y - br.y, tr.x - br.x), Math.hypot(tl.y - bl.y, tl.x - bl.x));

        let srcCoords = cv.matFromArray(4, 1, cv.CV_32FC2, [tl.x, tl.y, tr.x, tr.y, br.x, br.y, bl.x, bl.y]);
        let dstCoords = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, width, 0, width, height, 0, height]);

        let M = cv.getPerspectiveTransform(srcCoords, dstCoords);
        let dsize = new cv.Size(width, height);
        cv.warpPerspective(src, dst, M, dsize);
        
        scanMat = dst.clone();
        cv.imshow('canvasOutput', scanMat);
        
        // Cleanup warping mats
        M.delete(); srcCoords.delete(); dstCoords.delete();
    } else {
        // Fallback if no 4-corner shape found
        scanMat = src.clone();
        cv.imshow('canvasOutput', scanMat);
    }

    // Cleanup detection mats
    gray.delete(); blurred.delete(); edged.delete(); contours.delete(); hierarchy.delete();
}

function applyEffect(type) {
    let out = new cv.Mat();
    if (type === 'magic') {
        scanMat.convertTo(out, -1, 1.3, 30); // Brighten & Contrast
    } else if (type === 'bw') {
        cv.cvtColor(scanMat, out, cv.COLOR_RGBA2GRAY);
        cv.threshold(out, out, 120, 255, cv.THRESH_BINARY);
    } else if (type === 'orig') {
        cv.imshow('canvasOutput', srcMat);
        return;
    } else {
        out = scanMat.clone();
    }
    cv.imshow('canvasOutput', out);
    out.delete();
}

function exportPDF() {
    const { jsPDF } = window.jspdf;
    const imgData = canvas.toDataURL('image/jpeg', 0.9);
    const pdf = new jsPDF(canvas.width > canvas.height ? 'l' : 'p', 'px', [canvas.width, canvas.height]);
    pdf.addImage(imgData, 'JPEG', 0, 0, canvas.width, canvas.height);
    pdf.save("BoldScan.pdf");
}
</script>
</body>
</html>
